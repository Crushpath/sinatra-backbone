<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Sinatra-backbone</title>
    <link href="style.css" rel="stylesheet" />
    <link href='http://fonts.googleapis.com/css?family=Shanti:400|PT+Sans:700,700italic' rel='stylesheet' type='text/css'>
</head>
<body class='literate github'>
  
    <a href="https://github.com/rstacruz/sinatra-backbone"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://a248.e.akamai.net/assets.github.com/img/e6bef7a091f5f3138b8cd40bc3e114258dd68ddf/687474703a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f7265645f6161303030302e706e67" alt="Fork me on GitHub"></a>
  
  <div id='all'>



<hgroup class="header"><h1 id="sinatra-backbone">Sinatra-backbone</h1>
<h4>Neat integration of Backbone.js with Sinatra</h4></hgroup><p class=" brief">Do you like <a href="http://documentcloud.github.com/backbone/">Backbone.js</a>? Do you like <a href="http://sinatrarb.com">Sinatra</a>? Did you ever wish you 
can use them together? Well now you can, with the new Sinatra Backbone!</p>

<section class=" h4 usage"><h4>Usage</h4>

<p>This is a Ruby gem.<br><code>$ gem install sinatra-backbone --pre</code></p>

<p>Or do you use Bundler?<br><code>gem 'sinatra-backbone', :require =&gt; 'sinatra/backbone'</code></p>

<section class=" h2 contents"><h2 id="contents">Contents</h2>

<p><strong>Sinatra-backbone</strong> is comprised of two Sinatra plugins:</p>

<ul>
<li><p><code>Sinatra::JstPages</code> – Provides support for JavaScript server templates (JST) 
for use in Backbone views.</p></li>
<li><p><code>Sinatra::RestAPI</code> – Provides restful API for your models for use in Backbone 
models.</p></li>
</ul></section><section class="api h2 sinatra_jstpages_module"><h2 class="api" id="sinatra_jstpages_module">Sinatra::JstPages <span class="type">module</span>
</h2>
<p>A Sinatra plugin that adds support for JST (JavaScript Server Templates).</p>

<section class=" h4 basic_usage"><h4>Basic usage</h4>
<pre class=" lang- prettyprint right"><code>require 'sinatra/jstpages'

class App &lt; Sinatra::Base
  register Sinatra::JstPages
  serve_jst '/jst.js'
end
</code></pre>

<p>Register the <code>Sinatra::JstPages</code> plugin in your application, and use
<code>serve_jst</code>.  This example serves all JST files found in <code>/views/**/*.jst.*</code>
(where <code>/views</code> is your views directory as defined in Sinatra's
<code>settings.views</code>) as <code>http://localhost:4567/jst.js</code>.</p>

<br class="post-pre">

<pre class=" lang- prettyprint right"><code>&lt;script type='text/javascript' src='/jst.js'&gt;&lt;/script&gt;
</code></pre>
<p class=" after-pre">You will need to link to the JST route in your layout. Make a <code>&lt;script&gt;</code> tag
where the <code>src='...'</code> attribute is the same path you provide to <code>serve_jst</code>.</p>

<br class="post-pre">

<pre class=" lang- prettyprint right"><code># views/editor/edit.jst.jade
h1= "Edit "+name
  form
    button Save
</code></pre>
<p class=" after-pre">So, if you have a JST view written in Jade, placed in <code>views/editor/edit.jst.jade</code>:</p>

<br class="post-pre">

<pre class=" lang- prettyprint right"><code>// Renders the editor/edit template
JST['editor/edit']();

// Renders the editor/edit template with template parameters
JST['editor/edit']({name: 'Item Name'});
</code></pre>
<p class=" after-pre">Now in your browser you may invoke <code>JST['templatename']</code>:</p>

<br class="post-pre">

</section><section class=" after-pre h4 using_sinatra-assetpack"><h4 class=" after-pre">Using Sinatra-AssetPack?</h4>

<p><strong>TIP:</strong> If you're using the <a href="http://ricostacruz.com/sinatra-assetpack">sinatra-assetpack</a> gem, just add <code>/jst.js</code>
to a package.  (If you're not using Sinatra AssetPack yet, you probably
should.)</p>

</section><section class=" h4 supported_templates"><h4>Supported templates</h4>

<p>Currently supports the following templates:</p>

<ul>
<li><p><a href="http://github.com/visionmedia/jade">Jade</a> (<code>.jst.jade</code>) -- Jade templates. This requires
<a href="http://github.com/visionmedia/jade">jade.js</a>. For older browsers, you will also need <a href="https://github.com/douglascrockford/JSON-js">json2.js</a>,
and an implementation of <a href="http://snippets.dzone.com/posts/show/701">String.prototype.trim</a>.</p></li>
<li><p><a href="http://documentcloud.github.com/underscore/#template">Underscore templates</a> (<code>.jst.tpl</code>) -- Simple templates by
underscore. This requires <a href="http://documentcloud.github.com/underscore">underscore.js</a>, which Backbone also
requires.</p></li>
<li><p><a href="https://github.com/creationix/haml-js">Haml.js</a> (<code>.jst.haml</code>) -- A JavaScript implementation of Haml.
Requires <a href="https://github.com/creationix/haml-js">haml.js</a>.</p></li>
<li><p><a href="https://github.com/sstephenson/eco">Eco</a> (<code>.jst.eco</code>) -- Embedded CoffeeScript templates. Requires
<a href="https://github.com/sstephenson/eco">eco.js</a> and <a href="http://coffeescript.org">coffee-script.js</a>.</p></li>
</ul>
<section class="api h3 serve_jst_path_options_class_method"><h3 class="api" id="serve_jst_path_options_class_method">serve_jst<span class="args">(path, [options])</span> <span class="type">class method</span>
</h3>
<p>Serves JST files in given <code>path</code>.</p>

</section></section></section><section class="api h2 sinatra_jstpages_engine_class"><h2 class="api" id="sinatra_jstpages_engine_class">Sinatra::JstPages::Engine <span class="type">class</span>
</h2>
<p>A template engine.</p>

<section class=" h4 adding_support_for_new_template_engines"><h4>Adding support for new template engines</h4>
<pre class=" lang- prettyprint right"><code>module Sinatra::JstPages
  class MyEngine &lt; Engine
    def function() "My.compile(#{contents.inspect})"; end
  end

  register 'my', MyEngine
end
</code></pre>

<p>You will need to subclass <code>Engine</code>, override at least the <code>function</code> method,
then use <code>JstPages.register</code>.</p>

<p>This example will register <code>.jst.my</code> files to a new engine that uses
<code>My.compile</code>.</p>

<br class="post-pre">

<section class="api after-pre h3 file_attribute"><h3 class="api after-pre" id="file_attribute">file <span class="type">attribute</span>
</h3>
<p>The string path of the template file.</p>

</section><section class="api h3 contents_method"><h3 class="api" id="contents_method">contents <span class="type">method</span>
</h3>
<p>Returns the contents of the template file as a string.</p>

</section><section class="api h3 function_method"><h3 class="api" id="function_method">function <span class="type">method</span>
</h3>
<p>The JavaScript function to invoke on the precompile'd object.</p>

<p>What this returns should, in JavaScript, return a function that can be
called with an object hash of the params to be passed onto the template.</p>

</section></section></section><section class="api h2 sinatra_restapi_module"><h2 class="api" id="sinatra_restapi_module">Sinatra::RestAPI <span class="type">module</span>
</h2>
<pre class=" lang- prettyprint right"><code>require 'sinatra/restapi'

class App &lt; Sinatra::Base
  register Sinatra::RestAPI
end
</code></pre>
<p>A plugin for providing rest API to models. Great for Backbone.js.</p>

<p>To use this, simply <code>register</code> it to your Sinatra Application.  You can then
use <code>rest_create</code> and <code>rest_resource</code> to create your routes.</p>

<br class="post-pre">

<section class="api after-pre h3 rest_create_path_block_method"><h3 class="api after-pre" id="rest_create_path_block_method">rest_create<span class="args">(path, &amp;block)</span> <span class="type">method</span>
</h3>
<pre class=" lang- prettyprint right"><code>class App &lt; Sinatra::Base
  rest_create "/documents" do
    Document.new
  end
end
</code></pre>
<p>Creates a <em>create</em> route on the given <code>path</code>.</p>

<p>This creates a <code>POST</code> route in <em>/documents</em> that accepts JSON data.
This route will return the created object as JSON.</p>

<p>When getting a request, it does the following:</p>

<ul>
<li><p>A new object is created by <em>yielding</em> the block you give. (Let's
call it <code>object</code>.)</p></li>
<li><p>For each of the attributes, it uses the <code>attrib_name=</code> method in
your record. For instance, for an attrib like <code>title</code>, it wil lbe
calling <code>object.title = "hello"</code>.</p></li>
<li><p><code>object.save</code> will be called.</p></li>
<li><p><code>object</code>'s contents will then be returned to the client as JSON.</p></li>
</ul>
<p>See the example.</p>

<br class="post-pre">

</section><section class="api after-pre h3 rest_resource_path_block_method"><h3 class="api after-pre" id="rest_resource_path_block_method">rest_resource<span class="args">(path, &amp;block)</span> <span class="type">method</span>
</h3>
<pre class=" lang- prettyprint right"><code>class App &lt; Sinatra::Base
  rest_resource "/document/:id" do |id|
    Document.find(id)
  end
end
</code></pre>
<p>Creates a <em>get</em>, <em>edit</em> and <em>delete</em> route on the given <code>path</code>.</p>

<p>The block given will be yielded to do a record lookup. If the block returns
<code>nil</code>, RestAPI will return a <em>404</em>.</p>

<p>In the example, it creates routes for <code>/document/:id</code> to accept HTTP <em>GET</em>
(for object retrieval), <em>PUT</em> (for editing), and <em>DELETE</em> (for destroying).</p>

<p>Your model needs to implement the following methods:</p>

<ul>
<li>
<code>save</code> (called on edit)</li>
<li>
<code>destroy</code> (called on delete)</li>
<li>
<code>&lt;attrib_name_here&gt;=</code> (called for each of the attributes on edit)</li>
</ul>
<p>If you only want to create routes for only one or two of the actions, you
may individually use:</p>

<ul>
<li><code>rest_get</code></li>
<li><code>rest_edit</code></li>
<li><code>rest_delete</code></li>
</ul>
<p>All the methods above take the same arguments as <code>rest_resource</code>.</p>

<br class="post-pre">

</section><section class="api after-pre h3 rest_get_path_block_method"><h3 class="api after-pre" id="rest_get_path_block_method">rest_get<span class="args">(path, &amp;block)</span> <span class="type">method</span>
</h3>
<p>This is the same as <code>rest_resource</code>, but only handles <em>GET</em> requests.</p>

</section><section class="api h3 rest_edit_path_block_method"><h3 class="api" id="rest_edit_path_block_method">rest_edit<span class="args">(path, &amp;block)</span> <span class="type">method</span>
</h3>
<p>This is the same as <code>rest_resource</code>, but only handles <em>PUT</em>/<em>POST</em> (edit)
requests.</p>

</section><section class="api h3 rest_delete_path_block_method"><h3 class="api" id="rest_delete_path_block_method">rest_delete<span class="args">(path, &amp;block)</span> <span class="type">method</span>
</h3>
<p>This is the same as <code>rest_resource</code>, but only handles <em>DELETE</em> (edit)
requests. This uses <code>Model#destroy</code> on your model.</p>

</section><section class="api h3 json_conversion"><h3 class="api" id="json_conversion">JSON conversion <span class="type"></span>
</h3>
<p>The <em>create</em> and <em>get</em> routes all need to return objects as JSON. RestAPI
attempts to convert your model instances to JSON by first trying
<code>object.to_json</code> on it, then trying <code>object.to_hash.to_json</code>.</p>

<p>It's recommended you implement <code>#to_hash</code> in your models.</p>

</section><section class="api h3 helper_methods"><h3 class="api" id="helper_methods">Helper methods <span class="type"></span>
</h3>
<p>There are some helper methods that are used internally be <code>RestAPI</code>,
but you can use them too if you need them.</p>

<section class="api h4 rest_respond_object"><h4 class="api">rest_respond<span class="args">(object)</span> <span class="type"></span>
</h4>
<p>Responds with a request with the given <code>object</code>.</p>

<p>This will convert that object to either JSON or XML as needed, depending
on the client's preferred type (dictated by the HTTP <em>Accepts</em> header).</p>

</section><section class="api h4 rest_params"><h4 class="api">rest_params <span class="type"></span>
</h4>
<p>Returns the object from the request.</p>

<p>If the client sent <code>application/json</code> (or <code>text/json</code>) as the content
type, it tries to parse the request body as JSON.</p>

<p>If the client sent a standard URL-encoded POST with a <code>model</code> key
(happens when Backbone uses <code>Backbone.emulateJSON = true</code>), it tries
to parse its value as JSON.</p>

<p>Otherwise, the params will be returned as is.</p>


</section></section></section><section class=" h2 acknowledgements"><h2 id="acknowledgements">Acknowledgements</h2>

<p>© 2011, Rico Sta. Cruz. Released under the <a href="http://www.opensource.org/licenses/mit-license.php">MIT 
License</a>.</p>

<p>Sinatra-Backbone is authored and maintained by <a href="http://ricostacruz.com">Rico Sta. Cruz</a> with help 
from it's <a href="http://github.com/rstacruz/xxxxx">contributors</a>. It is sponsored by my startup, <a href="http://sinefunc.com">Sinefunc, Inc</a>.</p>

<ul>
<li>
<a href="http://ricostacruz.com">My website</a> (ricostacruz.com)</li>
<li>
<a href="http://sinefunc.com">Sinefunc, Inc.</a> (sinefunc.com)</li>
<li>
<a href="http://github.com/rstacruz">Github</a> (@rstacruz)</li>
<li>
<a href="http://twitter.com/rstacruz">Twitter</a> (@rstacruz)</li>
</ul></section></section></div>
  <script type='text/javascript' src='http://cachedcommons.org/cache/prettify/1.0.0/javascripts/prettify-min.js'></script>
  <script>prettyPrint();</script>
</body>
</html>
